<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Vue </title>
</head>

<body>

</body>
<script type="text/javascript">


    // UI 渲染
    function cbUI(newval) {
        console.log('newval', newval)
        console.log('UI Render Function')
    }

    // 订阅模式 Dep
    class Dep {
        // 存放 Watch 对象的数组
        constructor() {
            this.subs = []
        }

        // 在subs 添加 Watch 对象
        addSubs(sub) {
            this.subs.push(sub)
        }

        notify() {
            // console.log('List Task Update', new Date().getTime())
            console.log('List Task Update', new Date().getTime())
            this.subs.forEach((list) => {
                list.update() // 更新视图
            })
        }
    }


    // 观察者模式
    // class Watcher {
    //     constructor() {
    //         Dep.target = this
    //     }

    //     update() {
    //         console.log('Dep UI Update')
    //     }
    // }

    let uid = 0;
    class Watcher {
        constructor() {
            this.id = ++uid;
        }

        update() {
            console.log('watch' + this.id + ' update');
            queueWatcher(this);
        }

        run() {
            console.log('watch' + this.id + '视图更新啦～');
        }
    }

    let has = {};
    let queue = [];
    let waiting = false;
    function queueWatcher(watcher) {
        const id = watcher.id;
        if (has[id] == null) {
            has[id] = true;
            queue.push(watcher);
            if (!waiting) {
                waiting = true;
                nextTick(flushSchedulerQueue);
            }
        }
    }


    function flushSchedulerQueue() {
        let watcher, id;
        for (index = 0; index < queue.length; index++) {
            watcher = queue[index];
            id = watcher.id;
            has[id] = null;
            watcher.run();
        }
        waiting = false;
    }



    // Dep.target = null


    // 监听属性变化 取值赋值
    function defineReactive(obj, key, value) {

        const dep = new Dep()

        Object.defineProperty(obj, key, {
            enumerable: true,
            configurable: true,
            get: function () {
                dep.addSubs(Dep.target)
                return value
            },
            set: function (newVal) {
                if (newVal === value) return;
                // cbUI(newVal)
                dep.notify()
            }
        })
    }


    function obsever(value) {
        if (!value || (typeof value !== 'object')) {
            return
        }
        // 遍临对象的每一个属性
        Object.keys(value).forEach((key) => {
            defineReactive(value, key, value[key])
        })
    }

    // 构造类
    class Vue {
        constructor(options) {
            this._data = options.data
            obsever(this._data)
            new Watcher()
        }
    }


    // 创建一个Vnode节点
    class VNode {
        constructor(tag, data, children, text, elm) {
            /*当前节点的标签名*/
            this.tag = tag;
            /*当前节点的一些数据信息，比如 props、attrs 等数据*/
            this.data = data;
            /*当前节点的子节点，是一个数组*/
            this.children = children;
            /*当前节点的文本*/
            this.text = text;
            /*当前虚拟节点对应的真实 dom 节点*/
            this.elm = elm;
        }
    }

    function createVNode(type, props = null
        , children = null) {
        if (props) {
            // 处理 props 相关逻辑，标准化 class 和 style
        }
        // 对 vnode 类型信息编码
        const shapeFlag = isString(type)
            ? 1 /* ELEMENT */
            : isSuspense(type)
                ? 128 /* SUSPENSE */
                : isTeleport(type)
                    ? 64 /* TELEPORT */
                    : isObject(type)
                        ? 4 /* STATEFUL_COMPONENT */
                        : isFunction(type)
                            ? 2 /* FUNCTIONAL_COMPONENT */
                            : 0
        const vnode = {
            type,
            props,
            shapeFlag,
            // 一些其他属性
        }
        // 标准化子节点，把不同数据类型的 children 转成数组或者文本类型
        normalizeChildren(vnode, children)
        return vnode
    }


    render(vnode, rootContainer)
    const render = (vnode, container) => {
        if (vnode == null) {
            // 销毁组件
            if (container._vnode) {
                unmount(container._vnode, null, null, true)
            }
        } else {
            // 创建或者更新组件
            patch(container._vnode || null, vnode, container)
        }
        // 缓存 vnode 节点，表示已经渲染
        container._vnode = vnode
    }

    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) => {
        // 如果存在新旧节点, 且新旧节点类型不同，则销毁旧节点
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1)
            unmount(n1, parentComponent, parentSuspense, true)
            n1 = null
        }
        const { type, shapeFlag } = n2
        switch (type) {
            case Text:
                // 处理文本节点
                break
            case Comment:
                // 处理注释节点
                break
            case Static:
                // 处理静态节点
                break
            case Fragment:
                // 处理 Fragment 元素
                break
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    // 处理普通 DOM 元素
                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    // 处理组件
                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    // 处理 TELEPORT
                }
                else if (shapeFlag & 128 /* SUSPENSE */) {
                    // 处理 SUSPENSE
                }
        }
    }

    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        if (n1 == null) {
            // 挂载组件
            mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)
        }
        else {
            // 更新组件
            updateComponent(n1, n2, parentComponent, optimized)
        }
    }

    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        // 创建组件实例
        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense))
        // 设置组件实例
        setupComponent(instance)
        // 设置并运行带副作用的渲染函数
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)
    }

    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
        // 创建响应式的副作用渲染函数
        instance.update = effect(function componentEffect() {
            if (!instance.isMounted) {
                // 渲染组件生成子树 vnode
                const subTree = (instance.subTree = renderComponentRoot(instance))
                // 把子树 vnode 挂载到 container 中
                patch(null, subTree, container, anchor, instance, parentSuspense, isSVG)
                // 保留渲染生成的子树根 DOM 节点
                initialVNode.el = subTree.el
                instance.isMounted = true
            }
            else {
                // 更新组件
            }
        }, prodEffectOptions)
    }




    // 创建一个空节点
    function createEmptyVNode() {
        const node = new VNode();
        node.text = '';
        return node;
    }

    // 创建一个文本节点
    function createTextVNode(val) {
        return new VNode(undefined, undefined, undefined, String(val));
    }

    // 克隆一个VNode节点
    function cloneVNode(node) {
        const cloneVnode = new VNode(
            node.tag,
            node.data,
            node.children,
            node.text,
            node.elm
        );
        return cloneVnode;
    }

    // create Abstract syntax tree AST
    // 正则解析字符串


    // nextTick
    let callbacks = [];
    let pending = false;
    function nextTick(cb) {
        callbacks.push(cb);
        if (!pending) {
            pending = true;
            setTimeout(flushCallbacks, 0);
        }
    }


    function flushCallbacks() {
        pending = false;
        const copies = callbacks.slice(0);
        callbacks.length = 0;
        for (let i = 0; i < copies.length; i++) {
            copies[i]();
        }
    }

    let o = new Vue({
        data: {
            msg: 'this is msg'
        }
    })

    o._data.msg = 'MSG'
    o._data.msg = 'MSG2'
    o._data.msg = 'MSG3'
    o._data.msg = 'MSG4'

</script>

</html>